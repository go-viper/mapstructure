package mapstructure

import (
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"sync"
)

func ExampleDecode() {
	type Person struct {
		Name   string
		Age    int
		Emails []string
		Extra  map[string]string
	}

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]any{
		"name":   "Mitchell",
		"age":    91,
		"emails": []string{"one", "two", "three"},
		"extra": map[string]string{
			"twitter": "mitchellh",
		},
	}

	var result Person
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person{Name:"Mitchell", Age:91, Emails:[]string{"one", "two", "three"}, Extra:map[string]string{"twitter":"mitchellh"}}
}

func ExampleDecode_errors() {
	type Person struct {
		Name   string
		Age    int
		Emails []string
		Extra  map[string]string
	}

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]any{
		"name":   123,
		"age":    "bad value",
		"emails": []int{1, 2, 3},
	}

	var result Person
	err := Decode(input, &result)
	if err == nil {
		panic("should have an error")
	}

	fmt.Println(err.Error())
	// Output:
	// decoding failed due to the following error(s):
	//
	// 'Name' expected type 'string', got unconvertible type 'int'
	// 'Age' expected type 'int', got unconvertible type 'string'
	// 'Emails[0]' expected type 'string', got unconvertible type 'int'
	// 'Emails[1]' expected type 'string', got unconvertible type 'int'
	// 'Emails[2]' expected type 'string', got unconvertible type 'int'
}

func ExampleDecode_metadata() {
	type Person struct {
		Name string
		Age  int
	}

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]any{
		"name":  "Mitchell",
		"age":   91,
		"email": "foo@bar.com",
	}

	// For metadata, we make a more advanced DecoderConfig so we can
	// more finely configure the decoder that is used. In this case, we
	// just tell the decoder we want to track metadata.
	var md Metadata
	var result Person
	config := &DecoderConfig{
		Metadata: &md,
		Result:   &result,
	}

	decoder, err := NewDecoder(config)
	if err != nil {
		panic(err)
	}

	if err := decoder.Decode(input); err != nil {
		panic(err)
	}

	fmt.Printf("Unused keys: %#v", md.Unused)
	// Output:
	// Unused keys: []string{"email"}
}

func ExampleDecode_weaklyTypedInput() {
	type Person struct {
		Name   string
		Age    int
		Emails []string
	}

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON, generated by a weakly typed language
	// such as PHP.
	input := map[string]any{
		"name":   123,              // number => string
		"age":    "42",             // string => number
		"emails": map[string]any{}, // empty map => empty array
	}

	var result Person
	config := &DecoderConfig{
		WeaklyTypedInput: true,
		Result:           &result,
	}

	decoder, err := NewDecoder(config)
	if err != nil {
		panic(err)
	}

	err = decoder.Decode(input)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output: mapstructure.Person{Name:"123", Age:42, Emails:[]string{}}
}

func ExampleDecode_tags() {
	// Note that the mapstructure tags defined in the struct type
	// can indicate which fields the values are mapped to.
	type Person struct {
		Name string `mapstructure:"person_name"`
		Age  int    `mapstructure:"person_age"`
	}

	input := map[string]any{
		"person_name": "Mitchell",
		"person_age":  91,
	}

	var result Person
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person{Name:"Mitchell", Age:91}
}

func ExampleDecode_embeddedStruct() {
	// Squashing multiple embedded structs is allowed using the squash tag.
	// This is demonstrated by creating a composite struct of multiple types
	// and decoding into it. In this case, a person can carry with it both
	// a Family and a Location, as well as their own FirstName.
	type Family struct {
		LastName string
	}
	type Location struct {
		City string
	}
	type Person struct {
		Family    `mapstructure:",squash"`
		Location  `mapstructure:",squash"`
		FirstName string
	}

	input := map[string]any{
		"FirstName": "Mitchell",
		"LastName":  "Hashimoto",
		"City":      "San Francisco",
	}

	var result Person
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%s %s, %s", result.FirstName, result.LastName, result.City)
	// Output:
	// Mitchell Hashimoto, San Francisco
}

func ExampleDecode_remainingData() {
	// Note that the mapstructure tags defined in the struct type
	// can indicate which fields the values are mapped to.
	type Person struct {
		Name  string
		Age   int
		Other map[string]any `mapstructure:",remain"`
	}

	input := map[string]any{
		"name":  "Mitchell",
		"age":   91,
		"email": "mitchell@example.com",
	}

	var result Person
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person{Name:"Mitchell", Age:91, Other:map[string]interface {}{"email":"mitchell@example.com"}}
}

func ExampleDecode_remainingDataDecodeBackToMapInFlatFormat() {
	// Note that the mapstructure tags defined in the struct type
	// can indicate which fields the values are mapped to.
	type Person struct {
		Name  string
		Age   int
		Other map[string]any `mapstructure:",remain"`
	}

	input := map[string]any{
		"name": "Luffy",
		"age":  19,
		"powers": []string{
			"Rubber Man",
			"Conqueror Haki",
		},
	}

	var person Person
	err := Decode(input, &person)
	if err != nil {
		panic(err)
	}

	result := make(map[string]any)
	err = Decode(&person, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output:
	// map[string]interface {}{"Age":19, "Name":"Luffy", "powers":[]string{"Rubber Man", "Conqueror Haki"}}
}

func ExampleDecode_omitempty() {
	// Add omitempty annotation to avoid map keys for empty values
	type Family struct {
		LastName string
	}
	type Location struct {
		City string
	}
	type Person struct {
		*Family   `mapstructure:",omitempty"`
		*Location `mapstructure:",omitempty"`
		Age       int
		FirstName string
	}

	result := &map[string]any{}
	input := Person{FirstName: "Somebody"}
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%+v", result)
	// Output:
	// &map[Age:0 FirstName:Somebody]
}

func ExampleDecode_decodeHookFunc() {
	type PersonLocation struct {
		Latitude   float64
		Longtitude float64
	}

	type Person struct {
		Name     string
		Location PersonLocation
	}

	// Example of parsing messy input: here we have latitude, longitude squashed into
	// a single string field. We write a custom DecodeHookFunc to parse the '#' separated
	// values into a PersonLocation struct.
	input := map[string]any{
		"name":     "Mitchell",
		"location": "-35.2809#149.1300",
	}

	toPersonLocationHookFunc := func() DecodeHookFunc {
		return func(f reflect.Type, t reflect.Type, data any) (any, error) {
			if t != reflect.TypeOf(PersonLocation{}) {
				return data, nil
			}

			switch f.Kind() {
			case reflect.String:
				xs := strings.Split(data.(string), "#")

				if len(xs) == 2 {
					lat, errLat := strconv.ParseFloat(xs[0], 64)
					lon, errLon := strconv.ParseFloat(xs[1], 64)

					if errLat == nil && errLon == nil {
						return PersonLocation{Latitude: lat, Longtitude: lon}, nil
					}
				} else {
					return data, nil
				}
			}
			return data, nil
		}
	}

	var result Person

	decoder, errDecoder := NewDecoder(&DecoderConfig{
		Metadata:   nil,
		DecodeHook: toPersonLocationHookFunc(), // Here, use ComposeDecodeHookFunc to run multiple hooks.
		Result:     &result,
	})
	if errDecoder != nil {
		panic(errDecoder)
	}

	err := decoder.Decode(input)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person{Name:"Mitchell", Location:mapstructure.PersonLocation{Latitude:-35.2809, Longtitude:149.13}}
}

type CustomUnmarshaler struct {
	ID int64
}

func (c *CustomUnmarshaler) UnmarshalMapstructure(v interface{}) error {
	if sid, ok := v.(string); ok {
		id, err := strconv.ParseInt(sid, 10, 64)
		if err != nil {
			return fmt.Errorf("error converting id to int, %v", err)
		}
		c.ID = id
		return nil

	}
	return fmt.Errorf("error unmarshaling")
}

func ExampleDecode_structImplementsUnmarshalerInterface() {
	type Custom struct {
		Unmarshalers []CustomUnmarshaler
	}
	input := map[string]interface{}{
		"unmarshalers": []string{"123456"},
	}
	var result Custom
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}
	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Custom{Unmarshalers:[]mapstructure.CustomUnmarshaler{mapstructure.CustomUnmarshaler{ID:123456}}}
}

// Config is an interface for cache configs. The configs can
// then be used to spawn new Cache providers.
//
// As part of this test the cache providers are omitted.
type Config interface {
	Name() string
}

type Configs []Config

// RedisConfig implements the Config interface and
// is used to launch a new Redis Cache Provider
type RedisConfig struct {
	Enabled  bool   `mapstructure:"enabled"`
	Host     string `mapstructure:"host"`
	Port     int    `mapstructure:"port"`
	Username string `mapstructure:"username"`
	Password string `mapstructure:"password"`
}

func (c *RedisConfig) Name() string {
	return "redis"
}

// MemcachedConfig implements the Config interface and
// is used to launch a new Memcached Cache Provider
type MemcachedConfig struct {
	Enabled bool   `mapstructure:"enabled"`
	Host    string `mapstructure:"host"`
	Port    int    `mapstructure:"port"`
}

func (m *MemcachedConfig) Name() string {
	return "memcached"
}

type CachesConfig struct {
	CacheConfig Configs `mapstructure:"-,omitempty"`
}

func (c *CachesConfig) UnmarshalMapstructure(in interface{}) error {
	*c = CachesConfig{}
	if err := UnmarshalWithInlineConfigs(c, in); err != nil {
		return err
	}
	return nil
}

// AppConfig simulates the configuration that will be used in an app
// that uses multiple cache providers.
type AppConfig struct {
	Cache []*CachesConfig `mapstructure:"caches"`
}

var (
	configFieldPrefix = "CACHES_"
	configNames       = make(map[string]Config)
	configFieldNames  = make(map[reflect.Type]string)
	configFields      []reflect.StructField

	configTypesMu sync.Mutex
	configTypes   = make(map[reflect.Type]reflect.Type)

	emptyStructType = reflect.TypeOf(struct{}{})
	configsType     = reflect.TypeOf(Configs{})
)

func getConfigType(out reflect.Type) reflect.Type {
	configTypesMu.Lock()
	defer configTypesMu.Unlock()
	if typ, ok := configTypes[out]; ok {
		return typ
	}
	// Initial exported fields map one-to-one.
	var fields []reflect.StructField
	for i, n := 0, out.NumField(); i < n; i++ {
		switch field := out.Field(i); {
		case field.PkgPath == "" && field.Type != configsType:
			fields = append(fields, field)
		default:
			fields = append(fields, reflect.StructField{
				Name:    "_" + field.Name, // Field must be unexported.
				PkgPath: out.PkgPath(),
				Type:    emptyStructType,
			})
		}
	}
	// Append extra config fields on the end.
	fields = append(fields, configFields...)
	typ := reflect.StructOf(fields)
	configTypes[out] = typ
	return typ
}

// UnmarshalWithInlineConfigs helps implement mapstructure.Unmarshaler interface for structs
// that have a Configs field that should be inlined.
func UnmarshalWithInlineConfigs(out interface{}, in interface{}) error {
	outVal := reflect.ValueOf(out)
	if outVal.Kind() != reflect.Ptr {
		return fmt.Errorf("can only unmarshal into a struct pointer: %T", out)
	}
	outVal = outVal.Elem()
	if outVal.Kind() != reflect.Struct {
		return fmt.Errorf("can only unmarshal into a struct pointer: %T", out)
	}
	outTyp := outVal.Type()

	cfgTyp := getConfigType(outTyp)
	cfgPtr := reflect.New(cfgTyp)
	cfgVal := cfgPtr.Elem()

	// Copy shared fields (defaults) to dynamic value.
	var configs *Configs
	for i, n := 0, outVal.NumField(); i < n; i++ {
		if outTyp.Field(i).Type == configsType {
			configs = outVal.Field(i).Addr().Interface().(*Configs)
			continue
		}
		if cfgTyp.Field(i).PkgPath != "" {
			continue // Field is unexported: ignore.
		}
		cfgVal.Field(i).Set(outVal.Field(i))
	}
	if configs == nil {
		return fmt.Errorf("configs field not found in type: %T", out)
	}

	if cfgPtr.CanInterface() {
		// since the downstream configuration objects don't need anything special
		// just call mapstructure.Decode
		if err := Decode(in, cfgPtr.Interface()); err != nil {
			return err
		}
	}

	// Copy shared fields from dynamic value.
	for i, n := 0, outVal.NumField(); i < n; i++ {
		if cfgTyp.Field(i).PkgPath != "" {
			continue // Field is unexported: ignore.
		}
		outVal.Field(i).Set(cfgVal.Field(i))
	}

	var err error
	*configs, err = readConfigs(cfgVal, outVal.NumField())
	return err
}

func readConfigs(structVal reflect.Value, startField int) (Configs, error) {
	var (
		configs Configs
	)
	for i, n := startField, structVal.NumField(); i < n; i++ {
		field := structVal.Field(i)
		if field.Kind() != reflect.Slice {
			panic("discovery: internal error: field is not a slice")
		}
		for k := 0; k < field.Len(); k++ {
			val := field.Index(k)
			if val.IsZero() || (val.Kind() == reflect.Ptr && val.Elem().IsZero()) {
				key := configFieldNames[field.Type().Elem()]
				key = strings.TrimPrefix(key, configFieldPrefix)
				return nil, fmt.Errorf("empty or null section in %s", key)
			}
			switch c := val.Interface().(type) {
			case Config:
				configs = append(configs, c)
			default:
				panic("stream: internal error: slice element is not a Config")
			}
		}
	}
	return configs, nil
}

// RegisterConfig registers the given Config type for mapstructure unmarshaling.
func RegisterConfig(config Config) {
	registerConfig(config.Name(), reflect.TypeOf(config), config)
}

func registerConfig(mapstructureKey string, elemType reflect.Type, config Config) {
	name := config.Name()
	if _, ok := configNames[name]; ok {
		return
	}
	configNames[name] = config

	fieldName := configFieldPrefix + mapstructureKey // Field must be exported.
	configFieldNames[elemType] = fieldName

	// Insert fields in sorted order.
	i := sort.Search(len(configFields), func(k int) bool {
		return fieldName < configFields[k].Name
	})
	configFields = append(configFields, reflect.StructField{}) // Add empty field at end.
	copy(configFields[i+1:], configFields[i:])                 // Shift fields to the right.
	configFields[i] = reflect.StructField{ // Write new field in place.
		Name: fieldName,
		Type: reflect.SliceOf(elemType),
		Tag:  reflect.StructTag(`mapstructure:"` + mapstructureKey + `,omitempty"`),
	}
}

func ExampleDecode_structImplementsUnmarshalerInterfaceDynamicFields() {
	// Given the following YAML structure, use the Unmarshaler interface
	// to inline the cache configurations
	//
	// caches:
	//  - redis:
	//      - enabled: true
	//        host: "localhost"
	//        port: 6379
	//        username: "user"
	//        password: "password"
	//  - memcached:
	//      - enabled: true
	//        host: "localhost"
	//        port: 11211
	input := map[string]interface{}{
		"caches": []interface{}{
			map[string]interface{}{
				"redis": []map[string]interface{}{
					{
						"enabled":  true,
						"host":     "localhost",
						"port":     6379,
						"username": "user",
						"password": "password",
					},
				},
			},
			map[string]interface{}{
				"memcached": []map[string]interface{}{
					{
						"enabled": true,
						"host":    "localhost",
						"port":    11211,
					},
				},
			},
		},
	}
	RegisterConfig(&RedisConfig{})
	RegisterConfig(&MemcachedConfig{})
	var result AppConfig
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}
	fmt.Printf("%#v\n", len(result.Cache))
	redis := result.Cache[0].CacheConfig[0].(*RedisConfig)
	fmt.Printf("%#v\n", redis)
	memcached := result.Cache[1].CacheConfig[0].(*MemcachedConfig)
	fmt.Printf("%#v", memcached)
	// Output:
	// 2
	// &mapstructure.RedisConfig{Enabled:true, Host:"localhost", Port:6379, Username:"user", Password:"password"}
	// &mapstructure.MemcachedConfig{Enabled:true, Host:"localhost", Port:11211}
}

func ExampleDecode_structImplementsUnmarshalerInterfaceDynamicFieldsOneFieldWithMultipleValues() {
	// Given the following YAML structure, use the Unmarshaler interface
	// to inline the cache configurations
	//
	// caches:
	//  - redis:
	//      - enabled: true
	//        host: "host1"
	//        port: 6379
	//        username: "user"
	//        password: "password"
	//  	- enabled: true
	//        host: "host2"
	//        port: 6379
	//        username: "user2"
	//        password: "password2"
	input := map[string]interface{}{
		"caches": []interface{}{
			map[string]interface{}{
				"redis": []map[string]interface{}{
					{
						"enabled":  true,
						"host":     "host1",
						"port":     6379,
						"username": "user",
						"password": "password",
					},
					{
						"enabled":  true,
						"host":     "host2",
						"port":     6379,
						"username": "user2",
						"password": "password2",
					},
				},
			},
		},
	}
	RegisterConfig(&RedisConfig{})
	RegisterConfig(&MemcachedConfig{})
	var result AppConfig
	err := Decode(input, &result)
	if err != nil {
		panic(err)
	}
	fmt.Printf("%#v\n", len(result.Cache))
	redisOne := result.Cache[0].CacheConfig[0].(*RedisConfig)
	fmt.Printf("%#v\n", redisOne)
	redisTwo := result.Cache[0].CacheConfig[1].(*RedisConfig)
	fmt.Printf("%#v", redisTwo)
	// Output:
	// 1
	// &mapstructure.RedisConfig{Enabled:true, Host:"host1", Port:6379, Username:"user", Password:"password"}
	// &mapstructure.RedisConfig{Enabled:true, Host:"host2", Port:6379, Username:"user2", Password:"password2"}
}
